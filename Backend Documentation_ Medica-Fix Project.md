# Backend Documentation: Medica-Fix Project

## 1. Introduction

This document provides comprehensive technical documentation for the backend system of the Medica-Fix project. The backend serves as the core engine powering the application, handling data management, business logic execution, user authentication, and communication with the frontend client and potentially external services. Its primary purpose is to provide a secure, scalable, and reliable foundation for the medical diagnostic features offered by the application, enabling users to submit medical data (such as images) and receive predictions generated by integrated deep learning models.

The backend is developed using the Laravel framework (version inferred from typical structure, specific version check recommended if needed), a popular and robust PHP framework known for its elegant syntax, extensive features, and strong community support. Laravel's Model-View-Controller (MVC) architectural pattern provides a structured approach to development, separating concerns and promoting code maintainability. The system leverages PHP as its primary programming language and likely utilizes a relational database management system (RDBMS) such as MySQL or PostgreSQL for persistent data storage (database configuration details typically reside in the `.env` file and database migration files).

Architecturally, the backend is designed as a RESTful API (Representational State Transfer Application Programming Interface). This approach allows for stateless communication between the client (e.g., a mobile or web application) and the server, using standard HTTP methods (GET, POST, PUT, DELETE) to perform operations on resources. Data exchange primarily occurs using the JSON (JavaScript Object Notation) format, a lightweight and widely adopted standard for web APIs. Laravel Sanctum is employed to handle API token-based authentication, ensuring that only authorized users can access protected resources and perform specific actions.



## 2. Authentication and Authorization

Secure access control is paramount in the Medica-Fix application due to the sensitive nature of medical data. The backend employs Laravel Sanctum, a lightweight and effective system designed for API authentication, to manage user access. Sanctum provides a straightforward way to issue API tokens to users, allowing them to authenticate their requests to protected endpoints.

### 2.1 Authentication Mechanism

The primary authentication method is token-based. When a user successfully registers or logs in, the system generates a unique, secure API token associated with their account. This token must be included in the `Authorization` header of subsequent requests to protected API endpoints, typically using the `Bearer` scheme (e.g., `Authorization: Bearer <token>`). The backend middleware intercepts incoming requests, validates the provided token, and identifies the authenticated user, granting access only if the token is valid and corresponds to an existing user.

### 2.2 Authentication API Endpoints

The following API endpoints handle user authentication workflows:

*   **User Registration (`POST /api/register`):** Allows new users to create an account. It requires the user's name, email address, and password (with confirmation). Upon successful registration, it creates a new user record in the database (hashing the password for security) and returns an API token for immediate use, along with basic user details.
*   **User Login (`POST /api/login`):** Authenticates existing users. It requires the user's email and password. If the credentials are valid (checked against the hashed password in the database), it generates and returns a new API token and user details. Invalid credentials result in an authentication error.
*   **User Logout (`POST /api/logout`):** Invalidates the user's current API token, effectively logging them out. This endpoint requires a valid authentication token to identify the session to terminate. Subsequent requests using the invalidated token will be denied.
*   **Password Reset Request (`POST /api/forgot-password`):** Initiates the password reset process. Users provide their registered email address. The backend sends an email containing a secure link (with a unique token) to this address, allowing the user to proceed with resetting their password.
*   **Password Reset Execution (`POST /api/reset-password`):** Completes the password reset process. The user submits the reset token (received via email), their email address, and their new desired password (with confirmation). The system validates the token and updates the user's password in the database.

### 2.3 Email Verification

To ensure the validity of user email addresses, the system incorporates an email verification process, leveraging Laravel's built-in `MustVerifyEmail` contract implemented in the `User` model. The relevant endpoints are:

*   **Send Verification Link (`POST /api/email/verification-notification`):** Authenticated users can request a new verification email to be sent to their registered address.
*   **Verify Email (`GET /api/email/verify/{id}/{hash}`):** This endpoint is accessed via the link sent in the verification email. It uses signed URLs (provided by Laravel) containing the user ID and a cryptographic hash to securely verify the email address upon access. This endpoint requires the user to be authenticated and uses middleware (`signed`) to validate the URL signature.
*   **Check Verification Status (`GET /api/email/verify`):** Allows an authenticated user (or the frontend application) to check if the user's email address has already been verified.

### 2.4 Token Management

API tokens are generated using Sanctum's `createToken` method on the `User` model. These are plain text tokens intended for use by SPA (Single Page Application) frontends or mobile applications. Tokens have a lifecycle; they are created upon login/registration and deleted upon logout. While Sanctum allows for token expiration configuration, the current implementation appears to rely on manual logout for token invalidation (as seen in the `logout` method deleting `currentAccessToken`). Further configuration for automatic token expiry could be considered for enhanced security.

### 2.5 Authorization (RBAC)

Authorization determines what actions an authenticated user is permitted to perform. While the `AuthController` handles authentication (verifying *who* the user is), the analyzed code does not explicitly show a detailed Role-Based Access Control (RBAC) system (e.g., distinguishing between regular users, doctors, administrators). The primary authorization check currently seems to be simply whether the user is authenticated via Sanctum (`auth:sanctum` middleware). If different user roles with varying permissions are required, implementing Laravel's Gates or Policies would be the standard approach to manage authorization rules effectively. This could be a potential area for future enhancement if not already implemented elsewhere in the codebase.



## 3. API Endpoints (Excluding Authentication)

The backend exposes a set of RESTful API endpoints to allow clients to interact with the application's resources and functionalities, beyond the authentication-related endpoints discussed previously. These endpoints follow standard REST conventions, using appropriate HTTP verbs (GET, POST, PUT, DELETE) for actions and returning data primarily in JSON format.

### 3.1 API Design Principles

The API aims to be RESTful, meaning:
*   **Stateless:** Each request from a client contains all the information needed to understand and process the request. The server does not store any client context between requests (authentication is handled via tokens).
*   **Resource-Oriented:** Endpoints are designed around resources (e.g., users, predictions). URLs typically represent these resources (e.g., `/api/profile`, `/api/predictions`).
*   **Standard HTTP Methods:** Uses GET for retrieving resources, POST for creating resources, PUT/PATCH for updating, and DELETE for removing resources.
*   **JSON Payload:** Data is exchanged using JSON for both request bodies and response payloads.
*   **Clear Status Codes:** Uses standard HTTP status codes (e.g., 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 404 Not Found, 500 Internal Server Error) to indicate the outcome of requests.

### 3.2 Key API Endpoints

Based on the code analysis, particularly the `AuthController` and model relationships, the following core endpoints (beyond authentication) are identified or inferred:

*   **Get User Profile (`GET /api/profile`):**
    *   **Description:** Retrieves the profile information for the currently authenticated user. Crucially, this endpoint also eager-loads the user's associated prediction history, including details about the AI model used and the specific prediction results (lung, breast, prostate, thyroid).
    *   **Authentication:** Required (uses `auth:sanctum` middleware).
    *   **Response:** JSON object containing user details (name, email, age, gender, etc.) and a nested array of `predictions`. Laravel Resources (`UserResource`, `PredictionResource`, etc.) are likely used to structure this output, controlling which fields are exposed.

*   **Prediction Endpoints (Inferred/Requires Further Analysis):**
    *   *Note: The provided code snippets focused heavily on authentication. Specific routes and controllers for handling the creation and retrieval of predictions need further examination within the `routes/api.php` file and potentially dedicated controllers (e.g., `PredictionController`).* 
    *   **Submit Data for Prediction (e.g., `POST /api/predict/{model_type}` or `POST /api/predictions`):**
        *   **Description (Hypothesized):** Allows an authenticated user to submit data (likely an image file upload and associated metadata) for analysis by a specific AI model (e.g., lung cancer detection). The backend would process the data, interact with the relevant AI model (potentially an external service or a locally integrated model), store the prediction results (`DlModelsPrediction` and specific type tables), and return the outcome.
        *   **Authentication:** Required.
        *   **Request:** Likely `multipart/form-data` for image uploads, including model identifier and potentially other parameters.
        *   **Response:** JSON object containing the prediction result, confidence score, advice, and potentially a reference to the stored prediction record.
    *   **List User Predictions (e.g., `GET /api/predictions`):**
        *   **Description (Hypothesized):** Retrieves a list of past predictions made by the authenticated user. This might be implicitly covered by the `/api/profile` endpoint already, but a dedicated endpoint for potentially paginated or filtered results could exist.
        *   **Authentication:** Required.
        *   **Response:** JSON array of prediction objects.

### 3.3 Request/Response Formatting

The API consistently uses JSON for request and response bodies. Laravel's Eloquent API Resources (`UserResource`, `PredictionResource`, `AiModelResource`, `LungPredictionResource`, etc., found in `app/Http/Resources/`) play a crucial role in transforming Eloquent models into standardized JSON responses. This allows fine-grained control over which model attributes are exposed in the API, ensuring consistency and preventing accidental leakage of sensitive internal data.

### 3.4 Error Handling

Laravel's default exception handling provides a baseline for error responses. Validation errors (e.g., missing required fields during registration) are typically returned with a `422 Unprocessable Entity` status code and a JSON body detailing the specific errors per field (as handled by `ValidationException`). Authentication failures result in `401 Unauthorized` or `403 Forbidden` responses. Not found errors (e.g., accessing a non-existent prediction) return `404 Not Found`. Unhandled server-side exceptions generally result in a `500 Internal Server Error`. Custom exception handling might be implemented in `app/Exceptions/Handler.php` for more specific API error responses.



## 4. Database Schema and Models

The persistence layer of the Medica-Fix backend relies on a relational database, managed through Laravel\'s Eloquent ORM (Object-Relational Mapper). Eloquent provides an elegant ActiveRecord implementation for interacting with the database, allowing developers to work with database tables through corresponding Model classes.

### 4.1 Database Structure Overview

The database schema is defined incrementally through migration files located in the `database/migrations` directory. Key tables identified through model analysis include:

*   `users`: Stores user account information.
*   `predictions`: A central table linking users, AI models, and general prediction results.
*   `dl_models_predictions`: Seems to store detailed results specifically from deep learning model predictions, including image paths.
*   `ai_models`: (Inferred) Likely stores information about the different AI models available in the system.
*   Specific Prediction Tables (e.g., `lung_predictions`, `breast_predictions`, `prostate_predictions`, `thyroid_predictions`): Store results specific to each type of medical prediction.
*   `personal_access_tokens`: Used by Laravel Sanctum to store API tokens.
*   Other standard Laravel tables (e.g., `password_resets`, `failed_jobs`, etc.) might also exist.

Relationships between these tables (e.g., one-to-many, one-to-one) are defined within the Eloquent models.

### 4.2 Key Eloquent Models

The following Eloquent models represent the core entities within the backend system:

*   **`App\Models\User`:**
    *   **Table:** `users`
    *   **Description:** Represents a registered user of the application.
    *   **Traits:**
        *   `HasApiTokens`: Enables API token management via Sanctum.
        *   `Notifiable`: Allows sending notifications (e.g., password reset emails).
        *   `HasFactory`: Enables the use of model factories for testing/seeding.
        *   Implements `MustVerifyEmail`: Integrates with Laravel\'s email verification system.
    *   **Fillable Fields:** `name`, `email`, `password`, `google_id` (suggests Google Sign-In capability), `age`, `gender`.
    *   **Relationships:**
        *   `predictions()`: Defines a one-to-many relationship with the `Prediction` model (`hasMany`). A user can have multiple predictions.

*   **`App\Models\Prediction`:**
    *   **Table:** `predictions`
    *   **Description:** Represents a general prediction record made within the system.
    *   **Fillable Fields:** `user_id`, `model_id`, `prediction` (the result), `confidence`, `advise`.
    *   **Relationships:**
        *   `user()`: Defines an inverse one-to-many relationship with the `User` model (`belongsTo`). Each prediction belongs to one user.
        *   `aiModel()`: Defines a relationship with the `AiModel` model (`belongsTo`), linking the prediction to the specific AI model used.
        *   `lungPrediction()`, `breastPrediction()`, `thyroidPrediction()`, `prostatePrediction()`: Define one-to-one relationships (`hasOne`) with specific prediction result tables, likely using the `predictions` table\'s primary key as the foreign key in the specific tables.

*   **`App\Models\DlModelsPrediction`:**
    *   **Table:** `dl_models_predictions`
    *   **Description:** Appears to store results specifically from deep learning models, potentially those involving image analysis.
    *   **Fillable Fields:** `user_id`, `model_id`, `image_path` (path to the analyzed image), `prediction`, `confidence`, `advise`.
    *   **Relationships:**
        *   `user()`: Defines a relationship with the `User` model (`belongsTo`).
        *   `model()`: Defines a relationship with an `AiModel` (or potentially a generic `Model`) class (`belongsTo`). *Note: The code shows `Model::class`, which might be ambiguous; clarification on the exact related model is needed.* 

*   **`App\Models\AiModel` (Inferred):**
    *   **Table:** `ai_models` (Assumed)
    *   **Description:** Likely stores details about each available AI model (e.g., name, type, version, description).
    *   **Fields (Hypothesized):** `id`, `name`, `type`, `description`, `version`, etc.
    *   **Relationships:**
        *   Likely has a one-to-many relationship with `Prediction` and `DlModelsPrediction` (`hasMany`).

*   **Specific Prediction Models (`LungPrediction`, `BreastPrediction`, etc.):**
    *   **Tables:** `lung_predictions`, `breast_predictions`, etc. (Assumed)
    *   **Description:** Store detailed results or specific fields relevant only to that particular type of prediction.
    *   **Fields:** Vary depending on the prediction type.
    *   **Relationships:**
        *   Each likely has an inverse one-to-one relationship with the `Prediction` model (`belongsTo`).

### 4.3 Migrations

Database schema changes are managed through migration files (`database/migrations`). These files contain PHP code defining table structures, columns, indexes, and relationships. Running `php artisan migrate` applies pending migrations, ensuring the database schema is up-to-date and consistent across different development environments. Key migrations identified include creating the `personal_access_tokens` table and the `dl_models_predictions` table.



## 5. Core Logic and Business Rules

This section delves into the central processing logic and key business rules implemented within the Medica-Fix backend. While a complete deep dive requires analyzing specific controllers beyond `AuthController`, the existing analysis provides insights into the expected flow for core functionalities like predictions.

### 5.1 Prediction Process Flow (Hypothesized)

Based on the models (`Prediction`, `DlModelsPrediction`, specific types like `LungPrediction`) and the inferred API endpoints, a typical prediction workflow likely involves the following steps:

1.  **Request Initiation:** An authenticated user submits a request to a prediction endpoint (e.g., `POST /api/predict/{model_type}`) via the frontend client. This request includes necessary data, potentially an image file (`multipart/form-data`) and metadata identifying the target AI model.
2.  **Routing:** Laravel routes the incoming request to the appropriate controller method responsible for handling that specific prediction type or the general prediction endpoint.
3.  **Controller Handling:**
    *   **Validation:** The controller (or a dedicated Form Request class) validates the incoming data (e.g., ensuring an image file is present and valid, checking required metadata).
    *   **Data Processing/Preparation:** The controller might perform initial processing on the input data, such as storing the uploaded image securely (e.g., using Laravel\\'s Storage facade, potentially linking to the `image_path` in `DlModelsPrediction`).
    *   **AI Model Interaction:** The controller or a dedicated service class interacts with the relevant AI model. This interaction could involve:
        *   Calling an external AI service API.
        *   Executing a local script (e.g., Python) that runs the model.
        *   Utilizing a PHP library integrated with a machine learning framework.
    *   **Result Handling:** The controller receives the prediction results (e.g., predicted condition, confidence score) from the AI model.
4.  **Data Persistence:**
    *   The controller creates records in the relevant database tables:
        *   A record in `dl_models_predictions` storing the user ID, model ID, image path, prediction, confidence, and advice.
        *   Potentially a corresponding record in the general `predictions` table.
        *   A record in the specific prediction type table (e.g., `lung_predictions`) if additional specific fields need to be stored.
    *   Eloquent models (`DlModelsPrediction`, `Prediction`, etc.) are used to create and save these records, automatically handling relationships.
5.  **Response Generation:** The controller formats the prediction results, confidence score, and any generated advice into a JSON response. Laravel API Resources (`PredictionResource`, etc.) are likely used here to ensure a consistent output structure.
6.  **Response Sending:** The backend sends the JSON response back to the client with an appropriate HTTP status code (e.g., 200 OK or 201 Created).

### 5.2 Handling Different Prediction Models

The system is designed to support multiple prediction models (Lung, Breast, Thyroid, Prostate, etc.), as evidenced by the distinct `hasOne` relationships in the `Prediction` model and the specific resource classes. The backend likely uses the `model_id` (or a parameter in the API route like `{model_type}`) to determine which AI model to invoke and how to process/store the results. Conditional logic within the controller or dedicated service classes for each model type would manage these variations.

### 5.3 Data Validation

Input validation is a critical business rule enforced throughout the backend. As seen in the `AuthController`, Laravel\\'s validation capabilities are used extensively:

*   **Form Requests:** Dedicated request classes (in `app/Http/Requests`) can encapsulate validation logic for specific endpoints, keeping controllers clean.
*   **Controller Validation:** The `$request->validate()` method provides a convenient way to define and execute validation rules directly within controller methods.
*   **Rules:** Standard validation rules (e.g., `required`, `email`, `string`, `min`, `max`, `confirmed`, `unique`) are applied to ensure data integrity and security before processing.

This validation prevents invalid data from entering the system, guards against errors, and provides immediate feedback to the user about input issues.



## 6. Security Considerations

Security is a critical aspect of the Medica-Fix backend, especially given the handling of potentially sensitive user and medical data. Several measures are implemented, leveraging both Laravel features and general best practices, to protect the system and its data.

### 6.1 Authentication Security

*   **Token-Based Authentication:** Laravel Sanctum is used for API authentication. Tokens are securely generated and must be passed via the `Authorization` header. This prevents credentials from being exposed in URLs.
*   **Password Hashing:** User passwords are never stored in plain text. Laravel\\'s `Hash::make()` function (using Bcrypt by default) is employed during registration and password reset to create strong, salted hashes of passwords. Password verification during login uses `Hash::check()`.
*   **Token Invalidation:** The `logout` endpoint explicitly deletes the current access token, ensuring that compromised or old tokens cannot be reused after a user logs out.
*   **Secure Password Reset:** The password reset mechanism uses time-limited, unique tokens sent via email, preventing unauthorized password changes.
*   **Email Verification:** Verifying user emails adds a layer of account security, ensuring the registered email address is valid and accessible by the user.

### 6.2 Input Validation

Robust input validation, as described in the Core Logic section, is a fundamental security measure. By strictly validating all incoming data from API requests using Laravel\\'s validation rules (`required`, `email`, `string`, `min`, `max`, etc.), the backend protects against various injection attacks, including:
*   **SQL Injection:** Eloquent ORM uses parameter binding by default, significantly mitigating SQL injection risks. Proper validation further ensures that unexpected data types or formats do not reach database queries.
*   **Cross-Site Scripting (XSS):** While primarily a frontend concern, validating input on the backend prevents malicious scripts from being stored in the database and potentially rendered later by clients. Laravel\\'s Blade templating engine (if used for any server-rendered views) also provides XSS protection by default.

### 6.3 Authorization Checks

The `auth:sanctum` middleware ensures that only authenticated users can access protected endpoints like `/api/profile`. While detailed RBAC wasn\\'t explicitly observed, this base-level check prevents anonymous access to sensitive user data and functionalities.

### 6.4 Protection Against Common Vulnerabilities

*   **Cross-Site Request Forgery (CSRF):** Laravel includes built-in CSRF protection, typically relevant for web routes using sessions. For stateless APIs using tokens like this backend, CSRF is generally less of a concern, as requests rely on the `Authorization` header rather than session cookies. However, ensuring the frontend client correctly handles token storage and transmission is important.
*   **Mass Assignment:** Eloquent models use the `$fillable` property (as seen in `User`, `Prediction`, `DlModelsPrediction`) to explicitly define which attributes can be mass-assigned. This prevents malicious users from potentially updating sensitive fields (like an `is_admin` flag, if it existed) by manipulating request payloads.

### 6.5 Data Privacy

Handling medical data requires adherence to privacy regulations (like HIPAA, GDPR, depending on the target region). While specific compliance measures are beyond code analysis, the backend should ensure:
*   **Secure Storage:** Sensitive data in the database should be protected.
*   **Controlled Access:** Only authorized users should access specific patient data (potentially through future RBAC implementation).
*   **API Response Filtering:** Using API Resources ensures only necessary data fields are exposed via the API, minimizing data leakage.

### 6.6 Secure Communication (HTTPS)

It is crucial that the deployed application enforces HTTPS for all communication between the client and the backend API. This encrypts data in transit, protecting tokens, user credentials, and sensitive medical information from eavesdropping.


